# Lvalue Rvalue

Термины lvalue и rvalue не являются чем-то таким, с чем часто приходится сталкиваться при программировании на C/C++, а при встрече не сразу становится ясным, что именно они означают. Наиболее вероятное место столкнуться с ними — это сообщения компилятора.
```C++
int foo() { return 2; }
int main()
{
    foo() = 2;
    return 0;
}
```
При компиляции данного кода Вы увидите следующее:
```C++
test.c: In function 'main':
test.c:8:5: error: lvalue required as left operand of assignment
```
Видя код foo() = 2;, компилятор сообщает, что ожидает lvalue с левой стороны оператора присваивания.

Другой пример
```C++
int& foo()
{
    return 2;
}
```
```C++
testcpp.cpp: In function 'int& foo()':
testcpp.cpp:5:12: error: invalid initialization of non-const reference
of type 'int&' from an rvalue of type 'int'
```
## Простое определение
lvalue (locator value) представляет собой объект, который занимает __идентифицируемое место в памяти__ (например, имеет адрес).

rvalue определено путём исключения, говоря, что любое выражение является либо lvalue, либо rvalue. Таким образом из определения lvalue следует, что rvalue — это выражение, которое __не представляет собой объект, который занимает идентифицируемое место в памяти__.

## Элементарные примеры
```C++
int var;
var = 4;
```
Оператор присваивания ожидает lvalue с левой стороны, и var является lvalue, потому что это объект с идентифицируемым местом в памяти. 

С другой стороны, следующие _заклинания_ приведут к ошибкам:
```C++
4 = var;       // ERROR!
(var + 1) = 4; // ERROR!
```
Ни константа 4, ни выражение var + 1 не являются lvalue
(что автоматически их делает rvalue). Они не lvalue, потому что оба являются временным результатом выражений, которые не имеют определённого места в памяти (то есть они могут находится в каких-нибудь временных регистрах на время вычислений). Таким образом, присваивание в данном случае не несёт в себе никакого семантического смысла. Иными словами — __некуда присваивать__.

## Функции
Не все присваивания результату вызова функции ошибочны. Например, использование ссылок в C++ делает это возможным:
```C++
int globalvar = 20;

int& foo()
{
    return globalvar;
}

int main()
{
    foo() = 10;
    return 0;
}
```
Здесь foo возвращает ссылку, которая является lvalue, то есть ей можно придать значение. 

## Не изменяемые lvalue
```C++
const int a = 10; // 'a' - lvalue
a = 10;           // но ему не может быть присвоено значение! 
```
Таким образом не всем lvalue можно присвоить значение.

## Преобразования между lvalue и rvalue
```C++
int a = 1;        // a - lvalue
int b = 2;        // b - lvalue
int c = a + b;    // '+' требует rvalue, поэтому a и b конвертируются в rvalue 
                  // и rvalue возвращается в качестве результата
```
В третьей строке a и b подвергаются неявному преобразованию lvalue-в-rvalue.

Что насчёт преобразования в другую сторону? Можно ли преобразовать rvalue в lvalue? Конечно нет! 