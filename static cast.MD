# Static_cast

static_cast — унарная операция приведения типов данных в С++

Операция static_cast доступна только в языке C++. static_cast может быть использована для преобразования одного типа в другой, но она не должна быть использована для выполнения недопустимого преобразования, например, преобразование значения в указатель или наоборот. Рекомендуется пользоваться операцией static_cast, нежели Cи-стилем приведения, потому что static_cast ограничивает недопустимое приведение типов и, следовательно — безопаснее. Операция static_cast, грубо говоря, — это шаблон функции, в которой необходимо явно указать тип данных для преобразования, то есть задать параметр шаблона.
```C++
static_cast<dataType>(value);
```
Итак, в треугольных скобочках указывается тип данных, к которому необходимо преобразовать значение value, которое стоит в круглых скобочках. Смотрим все тот же пример, который приводит int к типу double для того, чтобы при делении 13-ти на 7 избежать усечения результата из-за целочисленного деления.
```C++
double res = static_cast<double>(13)/7;
```
Конвертация C-style

В программировании на языке Cи явное преобразование типов данных выполняется с помощью оператора (). Внутри круглых скобок мы пишем тип, в который нужно конвертировать. Этот способ конвертации типов называется конвертацией C-style. Например:

В программе, приведенной выше, мы используем круглые скобки, чтобы сообщить компилятору о необходимости преобразования переменной i1 (типа int) в тип float. Поскольку переменная i1 станет типа float, то i2 также затем автоматически преобразуется в тип float, и выполнится деление типа с плавающей точкой!

Язык C++ также позволяет использовать этот оператор следующим образом:

Конвертация C-style не проверяется компилятором во время компиляции, поэтому она может быть неправильно использована, например, при конвертации типов const или изменении типов данных, без учета их диапазонов (что может привести к переполнению).

Следовательно, конвертацию C-style лучше не использовать.

Основным преимуществом оператора static_cast является проверка его выполнения компилятором во время компиляции, что усложняет возможность возникновения непреднамеренных проблем.

Пример:
```C++
double res = static_cast<double>(13)/7; double res = double(13)/7;
```
Возможные преобразования типов

static_cast создан для выполнения всех видов преобразований, разрешённых компилятором. Все преобразования работают, только если есть совместимость по const и volatile.

1. Любое из преобразований типа, которые Си++ производит неявно (например, массива в указатель, одного числового типа в другой, void*-указателя в типизированный, неявный вызов конструктора). Явное написание static_cast может потребоваться, например:
* в шаблоне;

* для выбора, какую версию функции или операции использовать: auto hitRate = static_cast<float>(nHits) / nShots;

* чтобы подавить предупреждение компилятора «Возможна потеря точности»: double a = 1.0; auto b = static_cast<float>(a);

* чтобы согласовать типы в трёхместной условной операции: Base& x = use1 ? static_cast<Base&>(obj1) : static_cast<Base&>(obj2);.

2. Если соответствующее преобразование отмечено ключевым словом explicit.

3. Преобразование из/в тип enum class.
```C++
enum class TriBool { FAL, TRU, UNDEF, NN };

enum { TriBool_N = static_cast<int>(TriBool::NN) };

const char* triBoolNames[TriBool_N] = { "false", "true", "undef" };

auto x = TriBool::TRU;

std::cout << triBoolNames[static_cast<int>(x)] << std::endl;
```
4. Для явного указания, какую из перегруженных функций брать.
```C++
std::transform(s.begin(), s.end(), s.begin(), static_cast<int(*)(int)>(std::toupper));
```
5. Для преобразования указателей вниз по иерархии типов без проверки типа. В отличие от преобразования в стиле Си и reinterpret_cast, преобразование в неродственный класс невозможно.
```C++
void TSomeForm::someButtonClick(TObject* sender)

{

// Событие C++ Builder

// Мы знаем, что это TButton, ведь мы сами устанавливали событие

// в редакторе форм или конструкторе

TButton* bt = static_cast<TButton*>(sender);

bt->Caption = L"Clicked!";

}
```
Возможные логические ошибки.

Возможные ошибки зависят от того, какое преобразование проводится. Возможны переполнения, выход за диапазон и даже (для преобразования указателей) порча памяти.

Например, при преобразовании int → enum class переменная может заполучить недопустимое значение и программа не будет готова к этому.